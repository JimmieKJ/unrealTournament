// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2014 NVIDIA Corporation. All rights reserved.

#ifndef NX_MODULE_H
#define NX_MODULE_H

/*!
\file
\brief APEX Module API
*/

#include "NxApexInterface.h"
#include "NxApexSDK.h"
#include "foundation/PxSimpleTypes.h"

namespace physx
{
namespace apex
{

PX_PUSH_PACK_DEFAULT

class NxApexRenderableIterator;

/**
\brief A structure that holds two templated values, a min and a max
*/
template <typename T>
struct NxRange
{
	NxRange() {};
	/**
	\brief Constructor, sets min amd max values
	*/
	NxRange(T inMin, T inMax) : minimum(inMin), maximum(inMax) {};

	/**
	\brief operator ==
	*/
	bool operator== (const NxRange& r) const
	{
		return minimum == r.minimum && maximum == r.maximum;
	}

	/**
	\brief Minimal value
	*/
	T minimum;
	/**
	\brief Maximal value
	*/
	T maximum;
};


/**
\brief A named parameter with a range of possible integer values
*/
struct NxApexParameter
{
	NxApexParameter() : name(NULL), current(0) {};

	/**
	\brief Constructor, sets name, range and current value
	*/
	NxApexParameter(const char* inName, NxRange<physx::PxU32> inRange) : name(inName), range(inRange), current(inRange.minimum) {}

	/**
	\brief Name of the parameter
	*/
	const char* name;

	/**
	\brief Range for the parameter value
	*/
	NxRange<physx::PxU32> range;

	/**
	\brief Range for the parameter value
	*/
	physx::PxU32 current;
};

/**
\brief Scales a value from one range to another
*/
class NxInterpolator
{
public:
	/**
	\brief Scales a value from one range to another
	*/
	virtual physx::PxF32 interpolate(physx::PxF32 inCurrent, physx::PxF32 inMin, physx::PxF32 inMax, physx::PxF32 outMin, physx::PxF32 outMax) = 0;
};


/**
\brief base class of all APEX modules

It describes the LODParameters and weights defined by the module.
*/
class NxModule : public NxApexInterface
{
public:
	/**
	\brief Initialize the module
	\param[in] desc use NxModule::getDefaultModuleDesc() to get the descriptor necessary for initializing the module
	*/
	virtual void init(::NxParameterized::Interface& desc) = 0;

	/**
	\brief Returns the name of the module
	*/
	virtual const char* getName() const = 0;

	/**
	\brief Returns the unique ID of the module
	*/
	virtual NxAuthObjTypeID getModuleID() const = 0;

	/**
	\brief Returns the number of parameters of this module
	*/
	virtual physx::PxU32 getNbParameters() const = 0;

	/**
	\brief Returns an array of parameters.
	*/
	virtual NxApexParameter** getParameters() = 0;

	/**
	\brief Returns the NxParameterized interface that contains module initialization parameters
	\note The module itself owns this object, so there's no need for the application to destroy it
	*/
	virtual ::NxParameterized::Interface* getDefaultModuleDesc()
	{
		return NULL;
	}

	/**
	\brief Set a parameter

	Directly sets the current value of the parameter with the given index, bypassing
	any configuration manager.
	*/
	virtual void setIntValue(physx::PxU32 parameterIndex, physx::PxU32 value) = 0;

	/**
	\brief Allocate a renderable iterator

	Returns an NxApexRenderable iterator instance for the specified NxApexScene.  The iterator
	will return pointers to renderables in this scene that were generated by this module. This
	is the preferred method for rendering IOFX actors.
	*/
	virtual NxApexRenderableIterator* createRenderableIterator(const NxApexScene&) = 0;

	/**
	\brief Get the cost of one LOD aspect unit.
	*/
	virtual physx::PxF32 getLODUnitCost() const = 0;

	/**
	\brief Set the cost of one LOD aspect unit.
	*/
	virtual void setLODUnitCost(physx::PxF32) = 0;

	/**
	\brief Get the resource value of one unit of benefit.
	*/
	virtual physx::PxF32 getLODBenefitValue() const = 0;

	/**
	\brief Set the resource value of one unit of benefit.
	*/
	virtual void setLODBenefitValue(physx::PxF32) = 0;

	/**
	\brief Get enabled/disabled state of automatic LOD system.
	*/
	virtual bool getLODEnabled() const = 0;

	/**
	\brief Set enabled/disabled state of automatic LOD system.
	*/
	virtual void setLODEnabled(bool) = 0;
};

PX_POP_PACK

}
} // end namespace physx::apex

#endif // NX_MODULE_H
