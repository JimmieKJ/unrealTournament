// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	BasePassPixelShader.usf: Base pass pixel shader
=============================================================================*/

#include "Common.usf"
#include "SHCommon.usf"
#include "BasePassCommon.usf"
#include "Material.usf"
#include "VertexFactory.usf"
#include "LightmapCommon.usf"  
#include "ReflectionEnvironmentShared.usf"
#include "BRDF.usf"
#include "Random.usf"
#include "LightAccumulator.usf"
#include "DeferredShadingCommon.usf"
#include "VelocityCommon.usf"

#define PREV_FRAME_COLOR	1
#include "ScreenSpaceRayCast.usf"

#if TRANSLUCENT_SELF_SHADOWING

	#include "ShadowProjectionCommon.usf"

	float4x4 WorldToShadowMatrix;
	float4 ShadowUVMinMax;
	float3 DirectionalLightDirection;
	float4 DirectionalLightColor;
	 
#endif

#if MATERIAL_SHADINGMODEL_HAIR
#include "ShadingModels.usf"
#endif

Texture2D		HZBTexture;
SamplerState	HZBSampler;
Texture2D		PrevSceneColor;
SamplerState	PrevSceneColorSampler;

#ifndef COMPILER_GLSL
	#define COMPILER_GLSL 0
#endif

#define EDITOR_ALPHA2COVERAGE (USE_EDITOR_COMPOSITING && FEATURE_LEVEL >= FEATURE_LEVEL_SM5 && !COMPILER_GLSL)

#if TRANSLUCENCY_LIGHTING_SURFACE || TRANSLUCENCY_LIGHTING_SURFACE_PERPIXEL || MATERIAL_SHADINGMODEL_CLEAR_COAT

#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
	/** Prenormalized capture of the scene that's closest to the object being rendered, used for reflection environment on translucency. */
	TextureCubeArray ReflectionCubemap;
	SamplerState ReflectionCubemapSampler;
	int CubemapArrayIndex;
#else
	TextureCube ReflectionCubemap;
	SamplerState ReflectionCubemapSampler;
#endif

uint MortonCode( uint x )
{
	//x = (x ^ (x <<  8)) & 0x00ff00ff;
	//x = (x ^ (x <<  4)) & 0x0f0f0f0f;
	x = (x ^ (x <<  2)) & 0x33333333;
	x = (x ^ (x <<  1)) & 0x55555555;
	return x;
}

half3 GetImageBasedReflectionLighting(FMaterialPixelParameters MaterialParameters, half Roughness, half3 SpecularColor, half IndirectIrradiance)
{
	half AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness);

#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
	float4 SpecularIBL = TextureCubeArraySampleLevel(ReflectionCubemap, ReflectionCubemapSampler, MaterialParameters.ReflectionVector, CubemapArrayIndex, AbsoluteSpecularMip);
#else
	float4 SpecularIBL = TextureCubeSampleLevel(ReflectionCubemap, ReflectionCubemapSampler, MaterialParameters.ReflectionVector, AbsoluteSpecularMip);
#endif

#if ALLOW_STATIC_LIGHTING
	FLATTEN
	if (Frame.UseLightmaps > 0)
	{
		// Note: make sure this matches the lightmap mixing done on opaque (ReflectionEnvironmentTiledDeferredMain)
		SpecularIBL.rgb *= IndirectIrradiance;
	}
#endif

#if ENABLE_SKY_LIGHT || MATERIAL_SHADINGMODEL_CLEAR_COAT
	BRANCH
	if (SkyLightParameters.y > 0 && SpecularIBL.a < .999f)
	{
		// Normalize for static skylight types which mix with lightmaps
		bool bNormalize = SkyLightParameters.z < 1 && Frame.UseLightmaps;
		float3 SkyLighting = GetSkyLightReflection(MaterialParameters.ReflectionVector, Roughness, bNormalize);

		FLATTEN
		if (bNormalize)
		{
			SkyLighting *= IndirectIrradiance;
		}

		// Add in sky wherever reflection captures don't have coverage
		SpecularIBL.rgb += (1 - SpecularIBL.a) * SkyLighting;
	}
#endif

#if MATERIAL_SSR
	if( Frame.CameraCut == 0 )
	{
		//uint FrameRandom = (uint)(Frame.TemporalAAParams.r * 1551);
		uint FrameRandom = (Frame.FrameNumber & 15) * 1551;

		uint Morton = MortonCode( (uint)MaterialParameters.SvPosition.x & 3 ) | ( MortonCode( (uint)MaterialParameters.SvPosition.y & 3 ) * 2 );
		uint PixelIndex = ReverseBits32( Morton ) >> 28;
		//uint PixelIndex = ( (uint)MaterialParameters.SvPosition.x & 3 ) | ( ( (uint)MaterialParameters.SvPosition.y & 3 ) * 2 );
		//PixelIndex = ( PixelIndex * 1551 ) & 15;

		uint Offset = ( PixelIndex + FrameRandom ) & 15;
		float StepOffset = Offset / 15.0;
		StepOffset -= 0.5;
		
		float4 HitUVzTime;
		float HCBLevel;

		RayCast(
			HZBTexture, HZBSampler, float2(1, 1),
			MaterialParameters.WorldPosition_CamRelative, MaterialParameters.ReflectionVector, 0, 0, MaterialParameters.ScreenPosition.w,
			12, StepOffset,
			HitUVzTime, HCBLevel
		);

		// if there was a hit
		BRANCH if( HitUVzTime.w < 1 )
		{
			float4 SSR = SampleScreenColor( PrevSceneColor, PrevSceneColorSampler, HitUVzTime.xyz );
			SSR *= saturate( 2 - 6.6 * Roughness );
			SpecularIBL.rgb = SpecularIBL.rgb * (1 - SSR.a) + SSR.rgb;
		}
	}
#endif

	half NoV = saturate(dot(MaterialParameters.WorldNormal, MaterialParameters.CameraVector));
	SpecularColor = EnvBRDFApprox(SpecularColor, Roughness, NoV);

	return SpecularIBL.rgb * SpecularColor;
}

#endif

#if TRANSLUCENCY_LIGHTING_SURFACE_PERPIXEL
	#include "ForEachLight.usf"
#endif

void GetVolumeLightingNonDirectional(float4 AmbientLightingVector, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting)
{
	// Normal is not taken into account with non directional lighting, and only the ambient term of the SH coefficients are needed
	FOneBandSHVectorRGB TranslucentLighting;
	TranslucentLighting.R.V.x = AmbientLightingVector.r;
	TranslucentLighting.G.V.x = AmbientLightingVector.g;
	TranslucentLighting.B.V.x = AmbientLightingVector.b;

	FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
	VolumeLighting = float4(DotSH1(TranslucentLighting, DiffuseTransferSH), AmbientLightingVector.a);
	InterpolatedLighting = DiffuseColor * VolumeLighting.rgb;
}

void GetVolumeLightingDirectional(float4 AmbientLightingVector, float3 DirectionalLightingVector, float3 WorldNormal, float3 DiffuseColor, inout float3 InterpolatedLighting, out float4 VolumeLighting)
{
	float DirectionalLightingIntensity = GetMaterialTranslucencyDirectionalLightingIntensity();

	AmbientLightingVector.rgb /= DirectionalLightingIntensity;
	DirectionalLightingVector.rgb *= DirectionalLightingIntensity;

	// Reconstruct the SH coefficients based on what was encoded
	FTwoBandSHVectorRGB TranslucentLighting;
	TranslucentLighting.R.V.x = AmbientLightingVector.r;
	TranslucentLighting.G.V.x = AmbientLightingVector.g;
	TranslucentLighting.B.V.x = AmbientLightingVector.b;
	float3 NormalizedAmbientColor = AmbientLightingVector.rgb / Luminance( AmbientLightingVector.rgb );

	// Scale the monocrome directional coefficients with the normalzed ambient color as an approximation to the uncompressed values
	TranslucentLighting.R.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.r;
	TranslucentLighting.G.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.g;
	TranslucentLighting.B.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.b;
			
	// Compute diffuse lighting which takes the normal into account
	FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(WorldNormal, 1);
	VolumeLighting = float4(max(half3(0,0,0), DotSH(TranslucentLighting, DiffuseTransferSH)), AmbientLightingVector.a);
	InterpolatedLighting += DiffuseColor * VolumeLighting.rgb;
}

/** Calculates lighting for translucency. */
float3 GetTranslucencyLighting(
	FMaterialPixelParameters MaterialParameters, 
	FPixelMaterialInputs PixelMaterialInputs,
	FBasePassInterpolantsVSToPS BasePassInterpolants, 
	float3 DiffuseColor, 
	half Roughness, 
	half3 SpecularColor, 
	float IndirectIrradiance, 
	float MaterialAO)
{
	float4 VolumeLighting;
	float3 InterpolatedLighting = 0;

	float3 InnerVolumeUVs;
	float3 OuterVolumeUVs;
	float FinalLerpFactor;
	ComputeVolumeUVs(MaterialParameters.AbsoluteWorldPosition, MaterialParameters.LightingPositionOffset, InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);

	#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_DIRECTIONAL

		GetVolumeLightingDirectional(float4(BasePassInterpolants.AmbientLightingVector, 1), BasePassInterpolants.DirectionalLightingVector, MaterialParameters.WorldNormal, DiffuseColor, InterpolatedLighting, VolumeLighting);

	#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL

		GetVolumeLightingNonDirectional(float4(BasePassInterpolants.AmbientLightingVector, 1), DiffuseColor, InterpolatedLighting, VolumeLighting);

	#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_DIRECTIONAL || TRANSLUCENCY_LIGHTING_SURFACE
	
		float4 AmbientLightingVector = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
		float3 DirectionalLightingVector = GetDirectionalLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
		GetVolumeLightingDirectional(AmbientLightingVector, DirectionalLightingVector, MaterialParameters.WorldNormal, DiffuseColor, InterpolatedLighting, VolumeLighting);

	#elif TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL

		float4 AmbientLightingVector = GetAmbientLightingVectorFromTranslucentLightingVolume(InnerVolumeUVs, OuterVolumeUVs, FinalLerpFactor);
		GetVolumeLightingNonDirectional(AmbientLightingVector, DiffuseColor, InterpolatedLighting, VolumeLighting);

	#elif TRANSLUCENCY_LIGHTING_SURFACE_PERPIXEL

		InterpolatedLighting = AccumulateForwardLights(MaterialParameters, PixelMaterialInputs, DiffuseColor, Roughness, SpecularColor);

	#endif

	#if (TRANSLUCENCY_LIGHTING_VOLUMETRIC_DIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_SURFACE) && TRANSLUCENT_SELF_SHADOWING

		// Only apply self shadowing if the shadow hasn't faded out completely
		if (DirectionalLightColor.a > 0)
		{
			// Determine the shadow space position
			// Apply a stable offset to the world position used for shadowing, which blurs out high frequency details in the shadowmap with many layers
			float4 HomogeneousShadowPosition = mul(float4(MaterialParameters.AbsoluteWorldPosition + MaterialParameters.LightingPositionOffset, 1), WorldToShadowMatrix);
			float2 ShadowUVs = HomogeneousShadowPosition.xy / HomogeneousShadowPosition.w;
			// Lookup the shadow density at the point being shaded
			float3 ShadowDensity = CalculateTranslucencyShadowingDensity(ShadowUVs, HomogeneousShadowPosition.z) / GetMaterialTranslucentMultipleScatteringExtinction();
			// Compute colored transmission based on the density that the light ray passed through
			float3 SelfShadowing = saturate(exp(-ShadowDensity * GetMaterialTranslucentSelfShadowDensityScale()));
			// Compute a second shadow gradient to add interesting information in the shadowed area of the first
			// This is a stop gap for not having self shadowing from other light sources
			float3 SelfShadowing2 = lerp(float3(1, 1, 1), saturate(exp(-ShadowDensity * GetMaterialTranslucentSelfShadowSecondDensityScale())), GetMaterialTranslucentSelfShadowSecondOpacity());
			SelfShadowing = SelfShadowing * SelfShadowing2;

			// Force unshadowed if we read outside the valid area of the shadowmap atlas
			// This can happen if the particle system's bounds don't match its visible area
			FLATTEN
			if (any(ShadowUVs < ShadowUVMinMax.xy || ShadowUVs > ShadowUVMinMax.zw))
			{
				SelfShadowing = 1;
			}

			float3 BackscatteredLighting = 0;

			#if MATERIAL_SHADINGMODEL_SUBSURFACE

				float InScatterPower = GetMaterialTranslucentBackscatteringExponent();
				// Setup a pow lobe to approximate anisotropic in-scattering near to the light direction
				float InScattering = pow(saturate(dot(DirectionalLightDirection, MaterialParameters.CameraVector)), InScatterPower);

				float4 SSData = GetMaterialSubsurfaceData(MaterialParameters);
				float3 SubsurfaceColor = SSData.rgb;

				BackscatteredLighting = 
					SubsurfaceColor
					* InScattering 
					* DirectionalLightColor.rgb
					// Energy normalization, tighter lobes should be brighter
					* (InScatterPower + 2.0f) / 8.0f 
					// Mask by shadowing, exaggerated
					* SelfShadowing * SelfShadowing
					* VolumeLighting.a;
			#endif

			// The volume lighting already contains the contribution of the directional light, 
			// So calculate the amount of light to remove from the volume lighting in order to apply per-pixel self shadowing
			// VolumeLighting.a stores all attenuation and opaque shadow factors
			float3 SelfShadowingCorrection = DirectionalLightColor.rgb * VolumeLighting.a * (1 - SelfShadowing);
				
			// Combine backscattering and directional light self shadowing
			InterpolatedLighting = (BackscatteredLighting + DiffuseColor * max(VolumeLighting.rgb - SelfShadowingCorrection, 0));
		}

	#endif

	#if TRANSLUCENCY_LIGHTING_SURFACE || TRANSLUCENCY_LIGHTING_SURFACE_PERPIXEL
		InterpolatedLighting += GetImageBasedReflectionLighting(MaterialParameters, Roughness, SpecularColor, IndirectIrradiance);
	#endif

	return InterpolatedLighting;
}

/** Computes sky diffuse lighting, including precomputed shadowing. */
void GetSkyLighting(float3 WorldNormal, float2 LightmapUV, out float3 OutDiffuseLighting, out float3 OutSubsurfaceLighting)
{
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;

#if ENABLE_SKY_LIGHT

	float SkyVisibility = 1;
	float GeometryTerm = 1;
	float3 SkyLightingNormal = WorldNormal;
	
	#if HQ_TEXTURE_LIGHTMAP || CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING
		BRANCH
		if (Frame.SkyLightParameters.x > 0)
		{
			#if HQ_TEXTURE_LIGHTMAP

				// Bent normal from precomputed texture
				float4 WorldSkyBentNormalAndOcclusion = GetSkyBentNormalAndOcclusion(LightmapUV * float2(1, 2));
				// Renormalize as vector was quantized and compressed
				float3 NormalizedBentNormal = normalize(WorldSkyBentNormalAndOcclusion.xyz);
				SkyVisibility = WorldSkyBentNormalAndOcclusion.w;

			#elif CACHED_POINT_INDIRECT_LIGHTING || CACHED_VOLUME_INDIRECT_LIGHTING

				// Bent normal from the indirect lighting cache - one value for the whole object
				float3 NormalizedBentNormal = PrecomputedLightingBuffer.PointSkyBentNormal.xyz;
				SkyVisibility = PrecomputedLightingBuffer.PointSkyBentNormal.w;

			#endif

			#if (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE) && (TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL || TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL)
				// NonDirectional lighting can't depend on the normal
				SkyLightingNormal = NormalizedBentNormal;
			#else
				
				// Weight toward the material normal to increase directionality
				float BentNormalWeightFactor = 1 - (1 - SkyVisibility) * (1 - SkyVisibility);

				// We are lerping between the inputs of two lighting scenarios based on occlusion
				// In the mostly unoccluded case, evaluate sky lighting with the material normal, because it has higher detail
				// In the mostly occluded case, evaluate sky lighting with the bent normal, because it is a better representation of the incoming lighting
				// Then treat the lighting evaluated along the bent normal as an area light, so we must apply the lambert term
				SkyLightingNormal = lerp(NormalizedBentNormal, WorldNormal, BentNormalWeightFactor);

				float DotProductFactor = lerp(saturate(dot(NormalizedBentNormal, WorldNormal)), 1, BentNormalWeightFactor);
				// Account for darkening due to the geometry term
				GeometryTerm = DotProductFactor;
			#endif
		}
	#endif
			
	// Compute the preconvolved incoming lighting with the bent normal direction
	float3 DiffuseLookup = GetSkySHDiffuse(SkyLightingNormal) * Frame.SkyLightColor.rgb;

	// Apply AO to the sky diffuse
	OutDiffuseLighting += DiffuseLookup * (SkyVisibility * GeometryTerm);

	#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
		float3 BackfaceDiffuseLookup = GetSkySHDiffuse(-WorldNormal) * Frame.SkyLightColor.rgb;
		OutSubsurfaceLighting += BackfaceDiffuseLookup * SkyVisibility;
	#endif

#endif
}

/** Calculates indirect lighting contribution on this object from precomputed data. */
void GetPrecomputedIndirectLightingAndSkyLight(
	FMaterialPixelParameters MaterialParameters, 
	FVertexFactoryInterpolantsVSToPS Interpolants,
	FBasePassInterpolantsVSToPS BasePassInterpolants,
	float3 DiffuseDir,
	out float3 OutDiffuseLighting,
	out float3 OutSubsurfaceLighting,
	out float OutIndirectIrradiance)
{
	OutIndirectIrradiance = 0;
	OutDiffuseLighting = 0;
	OutSubsurfaceLighting = 0;
	float2 SkyOcclusionUV = 0;

	// Method for movable components which want to use a volume texture of interpolated SH samples
	#if CACHED_VOLUME_INDIRECT_LIGHTING
	
		// Compute volume teture UVs from world position
		float3 VolumeUVs = MaterialParameters.AbsoluteWorldPosition * PrecomputedLightingBuffer.IndirectLightingCachePrimitiveScale + PrecomputedLightingBuffer.IndirectLightingCachePrimitiveAdd;
		// Clamp UV to be within the valid region
		// Pixels outside of the object's bounding box would read garbage otherwise
		VolumeUVs = clamp(VolumeUVs, PrecomputedLightingBuffer.IndirectLightingCacheMinUV, PrecomputedLightingBuffer.IndirectLightingCacheMaxUV);
		float4 Vector0 = Texture3DSample(PrecomputedLightingBuffer.IndirectLightingCacheTexture0, PrecomputedLightingBuffer.IndirectLightingCacheTextureSampler0, VolumeUVs);

		// For debugging
		#define AMBIENTONLY 0
		#if AMBIENTONLY

			OutDiffuseLighting = Vector0.rgb / SHAmbientFunction() / PI;

		#else

			float4 Vector1 = Texture3DSample(PrecomputedLightingBuffer.IndirectLightingCacheTexture1, PrecomputedLightingBuffer.IndirectLightingCacheTextureSampler1, VolumeUVs);
			float4 Vector2 = Texture3DSample(PrecomputedLightingBuffer.IndirectLightingCacheTexture2, PrecomputedLightingBuffer.IndirectLightingCacheTextureSampler2, VolumeUVs);

			// Construct the SH environment
			FTwoBandSHVectorRGB CachedSH;
			CachedSH.R.V = float4(Vector0.x, Vector1.x, Vector2.x, Vector0.w);
			CachedSH.G.V = float4(Vector0.y, Vector1.y, Vector2.y, Vector1.w);
			CachedSH.B.V = float4(Vector0.z, Vector1.z, Vector2.z, Vector2.w);

			// Diffuse convolution
			FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(DiffuseDir, 1);
			OutDiffuseLighting = max(half3(0,0,0), DotSH(CachedSH, DiffuseTransferSH)) / PI;

			#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
				FTwoBandSHVector SubsurfaceTransferSH = CalcDiffuseTransferSH(-DiffuseDir, 1);
				OutSubsurfaceLighting += max(half3(0,0,0), DotSH(CachedSH, SubsurfaceTransferSH)) / PI;
			#endif

		#endif

	// Method for movable components which want to use a single interpolated SH sample
	#elif CACHED_POINT_INDIRECT_LIGHTING 
		#if TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL

			FOneBandSHVectorRGB PointIndirectLighting;
			PointIndirectLighting.R.V = PrecomputedLightingBuffer.IndirectLightingSHCoefficients[0].x;
			PointIndirectLighting.G.V = PrecomputedLightingBuffer.IndirectLightingSHCoefficients[1].x;
			PointIndirectLighting.B.V = PrecomputedLightingBuffer.IndirectLightingSHCoefficients[2].x;

			FOneBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH1(1);
			OutDiffuseLighting = DotSH1(PointIndirectLighting, DiffuseTransferSH);

			#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
				FOneBandSHVector SubsurfaceTransferSH = CalcDiffuseTransferSH1(1);
				OutSubsurfaceLighting += DotSH1(PointIndirectLighting, SubsurfaceTransferSH);
			#endif

		#else

			FTwoBandSHVectorRGB PointIndirectLighting;
			PointIndirectLighting.R.V = PrecomputedLightingBuffer.IndirectLightingSHCoefficients[0];
			PointIndirectLighting.G.V = PrecomputedLightingBuffer.IndirectLightingSHCoefficients[1];
			PointIndirectLighting.B.V = PrecomputedLightingBuffer.IndirectLightingSHCoefficients[2];

			FTwoBandSHVector DiffuseTransferSH = CalcDiffuseTransferSH(DiffuseDir, 1);
			// Compute diffuse lighting which takes the normal into account
			OutDiffuseLighting = max(half3(0,0,0), DotSH(PointIndirectLighting, DiffuseTransferSH));

			#if MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
				FTwoBandSHVector SubsurfaceTransferSH = CalcDiffuseTransferSH(-DiffuseDir, 1);
				OutSubsurfaceLighting += max(half3(0,0,0), DotSH(PointIndirectLighting, SubsurfaceTransferSH));
			#endif

		#endif

	// High quality texture lightmaps
	#elif HQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1);
		SkyOcclusionUV = LightmapUV0;
		GetLightMapColorHQ(LightmapUV0, LightmapUV1, DiffuseDir, OutDiffuseLighting, OutSubsurfaceLighting);

	// Low quality texture lightmaps
	#elif LQ_TEXTURE_LIGHTMAP

		float2 LightmapUV0, LightmapUV1;
		GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1);
		OutDiffuseLighting = GetLightMapColorLQ(LightmapUV0, LightmapUV1, DiffuseDir).rgb;

	#endif

	// Apply indirect lighting scale while we have only accumulated lightmaps
	OutDiffuseLighting *= Frame.IndirectLightingColorScale;

	float3 SkyDiffuseLighting;
	float3 SkySubsurfaceLighting;
	GetSkyLighting(DiffuseDir, SkyOcclusionUV, SkyDiffuseLighting, SkySubsurfaceLighting);

	OutSubsurfaceLighting += SkySubsurfaceLighting;

	BRANCH
	if( Frame.UseLightmaps > 0 || !ALLOW_STATIC_LIGHTING)
	{
		// Sky lighting must contribute to IndirectIrradiance for ReflectionEnvironment lightmap mixing
		OutDiffuseLighting += SkyDiffuseLighting;
	}
	else
	{
	#if (TRANSLUCENCY_LIGHTING_SURFACE || TRANSLUCENCY_LIGHTING_SURFACE_PERPIXEL) && FEATURE_LEVEL >= FEATURE_LEVEL_SM5
		float DiffuseMip = ComputeReflectionCaptureMipFromRoughness(1);
		float4 DiffuseIBL = TextureCubeArraySampleLevel(ReflectionCubemap, ReflectionCubemapSampler, DiffuseDir, CubemapArrayIndex, DiffuseMip);
		
		OutDiffuseLighting += DiffuseIBL.rgb + (1 - DiffuseIBL.a) * SkyDiffuseLighting;
	#endif
	}

	#if HQ_TEXTURE_LIGHTMAP || LQ_TEXTURE_LIGHTMAP || CACHED_VOLUME_INDIRECT_LIGHTING || CACHED_POINT_INDIRECT_LIGHTING
		OutIndirectIrradiance = Luminance(OutDiffuseLighting);
	#endif
}

#if USE_EDITOR_COMPOSITING
	bool bEnableEditorPrimitiveDepthTest;
	int MSAASampleCount;

	// depth in the red channel in DeviceZ
	Texture2D		FilteredSceneDepthTexture;
	SamplerState	FilteredSceneDepthTextureSampler;
#endif

// @return 0:translucent..1:opaque
float ClipForEditorPrimitives(FMaterialPixelParameters MaterialParameters)
{
	float Ret = 1;

#if USE_EDITOR_COMPOSITING && (FEATURE_LEVEL >= FEATURE_LEVEL_SM4 || MOBILE_EMULATION)
	// Depth test manually if compositing editor primitives since the depth buffer is different (MSAA only)
	BRANCH
	if (bEnableEditorPrimitiveDepthTest)
	{
#if HAS_INVERTED_Z_BUFFER
		//@todo-briank
		bool bIsPerspective = (ResolvedView.ViewToClip._m33 < 1.0f);
#endif	// HAS_INVERTED_Z_BUFFER
 		
		// dejitter the sample position and make a filtered lookup - for planes this allows to reconstruct a much less jittery depth comparison function, it however doesn't fix silhuetes
		float DeviceZ = Texture2DSampleLevel(FilteredSceneDepthTexture, FilteredSceneDepthTextureSampler, (MaterialParameters.SvPosition.xy - Frame.TemporalAAParams.zw) * Frame.BufferSizeAndInvSize.zw, 0).r;

		float PixelDeviceZ = MaterialParameters.SvPosition.z;

		// Soft Bias with DeviceZ for best quality
		const float DeviceDepthFade = 0.00005f;

		// 0.5f is to bias around the actual value, 1 or 0 are another option
		Ret = saturate(0.5f - (DeviceZ - PixelDeviceZ) / DeviceDepthFade);
	}
#endif	// USE_EDITOR_COMPOSITING && (FEATURE_LEVEL >= FEATURE_LEVEL_SM4 || MOBILE_EMULATION)

	// Note: multiple returns cause strange HLSL compiler error for CV_Coverage in later code
	return Ret;
}


#if EDITOR_ALPHA2COVERAGE != 0
uint CustomAlpha2Coverage(inout float4 InOutColor)
{
	uint MaskedCoverage = 0xff;

	MaskedCoverage = 0;

	uint EnabledSampleCount = 1;

	// todo: support non 4xMSAA as well

	// conservatively on but can be 0 if the opacity is too low
	if(InOutColor.a > 0.01f) { MaskedCoverage |= 0x1; }
	if(InOutColor.a > 0.25f) { MaskedCoverage |= 0x2; ++EnabledSampleCount; }
	if(InOutColor.a > 0.50f) { MaskedCoverage |= 0x4; ++EnabledSampleCount; }
	if(InOutColor.a > 0.75f) { MaskedCoverage |= 0x8; ++EnabledSampleCount; }

	// renormalize to make this sample the correct weight
	InOutColor *= (float)MSAASampleCount / EnabledSampleCount;

	return MaskedCoverage;
}
#endif

void ApplyPixelDepthOffsetForBasePass(inout FMaterialPixelParameters MaterialParameters, FPixelMaterialInputs PixelMaterialInputs, inout FBasePassInterpolantsVSToPS BasePassInterpolants, out float OutDepth)
{
	float PixelDepthOffset = ApplyPixelDepthOffsetToMaterialParameters(MaterialParameters, PixelMaterialInputs, OutDepth);

#if WRITES_VELOCITY_TO_GBUFFER
	BasePassInterpolants.VelocityPrevScreenPosition.w += PixelDepthOffset;

	#if WRITES_VELOCITY_TO_GBUFFER_USE_POS_INTERPOLATOR
		BasePassInterpolants.VelocityScreenPosition.w += PixelDepthOffset;
	#endif
#endif
}

#if USES_GBUFFER

// The selective output mask can only depend on defines, since the shadow will not export the data.
uint GetSelectiveOutputMask()
{
	uint Mask = 0;
#if !WRITES_CUSTOMDATA_TO_GBUFFER
	Mask |= SKIP_CUSTOMDATA_MASK;
#endif
#if !WRITES_PRECSHADOWFACTOR_TO_GBUFFER
	Mask |= SKIP_PRECSHADOW_MASK;
#endif
#if WRITES_PRECSHADOWFACTOR_ZERO
	Mask |= ZERO_PRECSHADOW_MASK;
#endif
#if !WRITES_VELOCITY_TO_GBUFFER
	Mask |= SKIP_VELOCITY_MASK;
#endif
	return Mask;
}
#endif // USES_GBUFFER

#if OUTPUT_GBUFFER_VELOCITY
#define GBUFFER_D_TARGET SV_Target5
#define GBUFFER_E_TARGET SV_Target6 // Only used with ALLOW_STATIC_LIGHTING
#else
#define GBUFFER_D_TARGET SV_Target4
#define GBUFFER_E_TARGET SV_Target5
#endif

void Main(
	FVertexFactoryInterpolantsVSToPS Interpolants,
	FBasePassInterpolantsVSToPS BasePassInterpolants,
	in INPUT_POSITION_QUALIFIERS float4 SvPosition : SV_Position
	OPTIONAL_IsFrontFace
	,out float4 OutColor		: SV_Target0

// Two options control the render target bindings : OUTPUT_GBUFFER_VELOCITY and ALLOW_STATIC_LIGHTING
#if USES_GBUFFER
	,out float4 OutGBufferA : SV_Target1 
	,out float4 OutGBufferB : SV_Target2
	,out float4 OutGBufferC : SV_Target3

// Big issue here on PC with AMD hardware : putting the velocity buffer after an optionnal RT fails!!!
#if WRITES_VELOCITY_TO_GBUFFER
	,out float4 OutGBufferVelocity : SV_Target4
#endif

#if WRITES_CUSTOMDATA_TO_GBUFFER
	,out float4 OutGBufferD : GBUFFER_D_TARGET
#endif

#if WRITES_PRECSHADOWFACTOR_TO_GBUFFER
	,out float4 OutGBufferE : GBUFFER_E_TARGET
#endif
#endif // USES_GBUFFER

	OPTIONAL_OutDepthConservative

#if EDITOR_ALPHA2COVERAGE != 0
   ,in uint InCoverage : SV_Coverage
   ,out uint OutCoverage : SV_Coverage
#endif
   )
{
#if INSTANCED_STEREO
	ResolvedView = ResolveView(GetEyeIndex(Interpolants.PackedEyeIndex));
#else
	ResolvedView = ResolveView();
#endif

#if !WRITES_CUSTOMDATA_TO_GBUFFER
	float4 OutGBufferD = 0;
#endif
#if !WRITES_PRECSHADOWFACTOR_TO_GBUFFER
	float4 OutGBufferE = 0;
#endif
#if !WRITES_VELOCITY_TO_GBUFFER
	float4 OutGBufferVelocity = 0;
#endif

#if EDITOR_ALPHA2COVERAGE != 0
	OutCoverage = InCoverage;
#endif

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Interpolants, SvPosition);
	FPixelMaterialInputs PixelMaterialInputs;
	
	#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		{
			float4 ScreenPosition = SvPositionToScreenPosition(SvPosition);
			CalcMaterialParametersEx(MaterialParameters, PixelMaterialInputs, SvPosition, ScreenPosition, bIsFrontFace, SvPositionToResolvedTranslatedWorld(SvPosition), BasePassInterpolants.PixelPositionExcludingWPO);
		}
	#else
		CalcMaterialParameters(MaterialParameters, PixelMaterialInputs, SvPosition, bIsFrontFace);
	#endif

#if USE_EDITOR_COMPOSITING && (FEATURE_LEVEL >= FEATURE_LEVEL_SM4 || MOBILE_EMULATION)
	const bool bEditorWeightedZBuffering = true;
#else
	const bool bEditorWeightedZBuffering = false;
#endif
		
#if OUTPUT_PIXEL_DEPTH_OFFSET
	ApplyPixelDepthOffsetForBasePass(MaterialParameters, PixelMaterialInputs, BasePassInterpolants, OutDepth);
#endif

	//Clip if the blend mode requires it.
	if(!bEditorWeightedZBuffering)
	{
		GetMaterialCoverageAndClipping(MaterialParameters, PixelMaterialInputs);
	}

#if HQ_TEXTURE_LIGHTMAP && USES_AO_MATERIAL_MASK && !MATERIAL_SHADINGMODEL_UNLIT
	float2 LightmapUV0, LightmapUV1;
	GetLightMapCoordinates(Interpolants, LightmapUV0, LightmapUV1);
	// Must be computed before GetMaterialBaseColor
	MaterialParameters.AOMaterialMask = GetAOMaterialMask(LightmapUV0 * float2(1, 2));
#endif

	// Store the results in local variables and reuse instead of calling the functions multiple times.
	half3 BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
	half  Metallic = GetMaterialMetallic(PixelMaterialInputs);
	half  Specular = GetMaterialSpecular(PixelMaterialInputs);

	float MaterialAO = GetMaterialAmbientOcclusion(PixelMaterialInputs);
	float Roughness = GetMaterialRoughness(PixelMaterialInputs);

	// 0..1, SubsurfaceProfileId = int(x * 255)
	float SubsurfaceProfile = 0;

	// If we don't use this shading model the color should be black (don't generate shader code for unused data, don't do indirectlighting cache lighting with this color).
	float3 SubsurfaceColor = 0;
#if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN || MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE || MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE || MATERIAL_SHADINGMODEL_CLOTH
	{
		float4 SubsurfaceData = GetMaterialSubsurfaceData(MaterialParameters);

#if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN || MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
		SubsurfaceColor = SubsurfaceData.rgb * Frame.DiffuseOverrideParameter.w + Frame.DiffuseOverrideParameter.xyz;
#elif MATERIAL_SHADINGMODEL_CLOTH
		SubsurfaceColor = SubsurfaceData.rgb;
#endif
		SubsurfaceProfile = SubsurfaceData.a;
	}
#endif

#if USE_DBUFFER && MATERIALDECALRESPONSEMASK && !(MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE || MATERIALBLENDING_MODULATE)
	// apply decals from the DBuffer
	BRANCH if(Primitive.DecalReceiverMask > 0)
	{
		float2 NDC = MaterialParameters.ScreenPosition.xy / MaterialParameters.ScreenPosition.w;
		
		// Note: We are using View and not ResolvedView here.
		// It has the correct ScreenPositionScaleBias values for screen space compositing.
		float2 ScreenUV = NDC * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
		
		FDBufferData DBufferData = GetDBufferData(ScreenUV);

		// the material can disable the DBuffer effects for better performance or control
		if((MATERIALDECALRESPONSEMASK & 0x1) == 0) { DBufferData.PreMulColor = 0; DBufferData.ColorOpacity = 1; }
		if((MATERIALDECALRESPONSEMASK & 0x2) == 0) { DBufferData.PreMulWorldNormal = 0; DBufferData.NormalOpacity = 1; }
		if((MATERIALDECALRESPONSEMASK & 0x4) == 0) { DBufferData.PreMulRoughness = 0; DBufferData.RoughnessOpacity = 1; }

		ApplyDBufferData(DBufferData, MaterialParameters.WorldNormal, SubsurfaceColor, Roughness, BaseColor, Metallic, Specular);
	}
#endif

	float3 LocalBaseColor = BaseColor;
	float LocalSpecular = Specular;

#if MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE
	// SubsurfaceProfile applies the BaseColor in a later pass. Any lighting output in the base pass needs
	// to separate specualar and diffuse lighting in a checkerboard pattern
	{
		bool bChecker = CheckerFromPixelPos(MaterialParameters.SvPosition.xy);

		LocalBaseColor = bChecker;
		LocalSpecular = !bChecker;
	}
#endif

	// So that the following code can still use DiffuseColor and SpecularColor.
	half3 DiffuseColor = LocalBaseColor - LocalBaseColor * Metallic;
	half3 SpecularColor = lerp( 0.08 * LocalSpecular.xxx, LocalBaseColor, Metallic.xxx );

#if USE_DEVELOPMENT_SHADERS
	{
		// this feature is only needed for development/editor - we can compile it out for a shipping build (see r.CompileShadersForDevelopment cvar help)
		DiffuseColor = DiffuseColor * Frame.DiffuseOverrideParameter.w + Frame.DiffuseOverrideParameter.xyz;
		SpecularColor = SpecularColor * Frame.SpecularOverrideParameter.w + Frame.SpecularOverrideParameter.xyz;
	}
#endif

	half Opacity = GetMaterialOpacity(PixelMaterialInputs);

	FGBufferData GBuffer = (FGBufferData)0;

	GBuffer.WorldNormal = MaterialParameters.WorldNormal;
	GBuffer.BaseColor = BaseColor;
	GBuffer.Metallic = Metallic;
	GBuffer.Specular = Specular;
	GBuffer.Roughness = Roughness;
	GBuffer.GBufferAO = MaterialAO;
	GBuffer.PerObjectGBufferData = Primitive.PerObjectGBufferData;

	#if MATERIAL_SHADINGMODEL_UNLIT
		GBuffer.ShadingModelID = SHADINGMODELID_UNLIT;
	#elif MATERIAL_SHADINGMODEL_DEFAULT_LIT
		GBuffer.ShadingModelID = SHADINGMODELID_DEFAULT_LIT;
	#elif MATERIAL_SHADINGMODEL_SUBSURFACE
		GBuffer.ShadingModelID = SHADINGMODELID_SUBSURFACE;
		GBuffer.CustomData.rgb = EncodeSubsurfaceColor(SubsurfaceColor);
		GBuffer.CustomData.a = Opacity;
	#elif MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN
		GBuffer.ShadingModelID = SHADINGMODELID_PREINTEGRATED_SKIN;
		GBuffer.CustomData.rgb = EncodeSubsurfaceColor(SubsurfaceColor);
		GBuffer.CustomData.a = Opacity;
	#elif MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE
		GBuffer.ShadingModelID = SHADINGMODELID_SUBSURFACE_PROFILE;
		GBuffer.CustomData.rgb = EncodeSubsurfaceProfile(SubsurfaceProfile);
		GBuffer.CustomData.a = Opacity;
	#elif MATERIAL_SHADINGMODEL_CLEAR_COAT
	{
		GBuffer.ShadingModelID = SHADINGMODELID_CLEAR_COAT;

		float ClearCoat				= saturate( GetMaterialCustomData0(MaterialParameters) );
		float ClearCoatRoughness	= saturate( GetMaterialCustomData1(MaterialParameters) );
		float MetalSpec = 0.9;

		float NoV = saturate( dot( MaterialParameters.WorldNormal, MaterialParameters.CameraVector ) );

		// Approximation of refraction's effect on EnvBRDF
		float RefractionScale = ( (NoV * 0.5 + 0.5) * NoV - 1 ) * saturate( 1.25 - 1.25 * Roughness ) + 1;

		// Approximation of absorption integral, tuned for Roughness=0.4
		float3 AbsorptionColor = BaseColor * (1 / MetalSpec);
		float3 Absorption = AbsorptionColor * ( (NoV - 1) * 0.85 * ( 1 - lerp( AbsorptionColor, Square(AbsorptionColor), -0.78 ) ) + 1 );

		GBuffer.BaseColor = lerp( BaseColor, lerp( BaseColor, MetalSpec * Absorption, Metallic ) * RefractionScale, ClearCoat );
		GBuffer.Specular *= lerp( 1, RefractionScale, ClearCoat );

		GBuffer.CustomData.x = ClearCoat;
		GBuffer.CustomData.y = ClearCoatRoughness;
	}
	#elif MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE
		GBuffer.ShadingModelID = SHADINGMODELID_TWOSIDED_FOLIAGE;
		GBuffer.CustomData.rgb = EncodeSubsurfaceColor(SubsurfaceColor);
		GBuffer.CustomData.a = Opacity;
	#elif MATERIAL_SHADINGMODEL_HAIR
		GBuffer.ShadingModelID = SHADINGMODELID_HAIR;
		GBuffer.CustomData.xy = UnitVectorToOctahedron( MaterialParameters.WorldNormal ) * 0.5 + 0.5;
		GBuffer.CustomData.z = saturate( GetMaterialCustomData0(MaterialParameters) );	// Backlit
	#elif MATERIAL_SHADINGMODEL_CLOTH
		GBuffer.ShadingModelID = SHADINGMODELID_CLOTH;
		GBuffer.CustomData.rgb = SubsurfaceColor;
		GBuffer.CustomData.a = saturate( GetMaterialCustomData0(MaterialParameters) );	// Cloth
		GBuffer.IndirectIrradiance *= 1 - GBuffer.CustomData.a;
	#elif MATERIAL_SHADINGMODEL_EYE
		GBuffer.ShadingModelID = SHADINGMODELID_EYE;
		#if NUM_MATERIAL_OUTPUTS_GETTANGENTOUTPUT > 0
			float3 Tangent = GetTangentOutput0(MaterialParameters);
			GBuffer.CustomData.xy = UnitVectorToOctahedron( normalize(Tangent) ) * 0.5 + 0.5;
		#endif
		GBuffer.CustomData.z = saturate( GetMaterialCustomData0(MaterialParameters) );	// Iris Mask
		GBuffer.CustomData.w = saturate( GetMaterialCustomData1(MaterialParameters) );	// Iris Distance
	#else
		// missing shading model, compiler should report ShadingModelID is not set
	#endif

	#if USES_GBUFFER
		GBuffer.SelectiveOutputMask = GetSelectiveOutputMask();

		#if WRITES_VELOCITY_TO_GBUFFER
			{
				// 2d velocity, includes camera an object motion
			#if WRITES_VELOCITY_TO_GBUFFER_USE_POS_INTERPOLATOR
				float2 Velocity = Calculate2DVelocity(BasePassInterpolants.VelocityScreenPosition, BasePassInterpolants.VelocityPrevScreenPosition);
			#else
				float2 Velocity = Calculate2DVelocity(MaterialParameters.ScreenPosition, BasePassInterpolants.VelocityPrevScreenPosition);
			#endif

				// Make sure not to touch 0,0 which is clear color
				GBuffer.Velocity = float4(EncodeVelocityToTexture(Velocity), 0, 0) * BasePassInterpolants.VelocityPrevScreenPosition.z;
			}
		#else
			GBuffer.Velocity = 0;
		#endif
	#endif


	half3 Color = 0;
	float IndirectIrradiance = 0;

	#if !MATERIAL_SHADINGMODEL_UNLIT

		float3 DiffuseDir = MaterialParameters.WorldNormal;
		float3 EffectiveDiffuseColor = DiffuseColor;

		#if MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN
			// Add subsurface energy to diffuse
			//@todo - better subsurface handling for these shading models with skylight and precomputed GI
			EffectiveDiffuseColor += SubsurfaceColor;
		#endif

		#if MATERIAL_SHADINGMODEL_CLOTH
			EffectiveDiffuseColor += SubsurfaceColor * saturate( GetMaterialCustomData0(MaterialParameters) );
		#endif

		#if MATERIAL_SHADINGMODEL_HAIR
		{
			float3 N = MaterialParameters.WorldNormal;
			float3 V = MaterialParameters.CameraVector;
			float3 L = normalize( V - N * dot(V,N) );
			DiffuseDir = L;
			EffectiveDiffuseColor = PI * HairShading( GBuffer, L, V, N, 1, 0, 0.2, uint2(0,0) );
		}
		#endif
			
		float3 DiffuseIndirectLighting;
		float3 SubsurfaceIndirectLighting;
		GetPrecomputedIndirectLightingAndSkyLight(MaterialParameters, Interpolants, BasePassInterpolants, DiffuseDir, DiffuseIndirectLighting, SubsurfaceIndirectLighting, IndirectIrradiance);
		
		Color += (DiffuseIndirectLighting * EffectiveDiffuseColor + SubsurfaceIndirectLighting * SubsurfaceColor) * MaterialAO;

		#if MATERIAL_SHADINGMODEL_CLEAR_COAT
		{
			const float ClearCoat			= GBuffer.CustomData.x;
			const float ClearCoatRoughness	= GBuffer.CustomData.y;

			// TODO EnvBRDF should have a mask param
			//float2 AB = PreIntegratedGF.SampleLevel( PreIntegratedGFSampler, float2( NoV, GBuffer.Roughness ), 0 ).rg;
			//Color.rgb *= GBuffer.SpecularColor * AB.x + AB.y * saturate( 50 * GBuffer.SpecularColor.g ) * (1 - ClearCoat);

			float3 N = MaterialParameters.WorldNormal;
			float3 V = MaterialParameters.CameraVector;
			float NoV = saturate( dot( N, V ) );

			// F_Schlick
			float F0 = 0.04;
			float Fc = Pow5( 1 - NoV );
			float F = Fc + (1 - Fc) * F0;
			F *= ClearCoat;
			
			float LayerAttenuation = (1 - F);

			Color += LayerAttenuation * GetImageBasedReflectionLighting(MaterialParameters, GBuffer.Roughness, SpecularColor, IndirectIrradiance);
		}
		#endif

		#if SIMPLE_DYNAMIC_LIGHTING
			// always unshadowed so BiasedNDotL is not needed
			half Lambert = saturate(dot(MaterialParameters.WorldNormal, Frame.DirectionalLightDirection));
			Color += DiffuseColor * Lambert * Frame.DirectionalLightColor.rgb;

			Color += GetMaterialHemisphereLightTransferFull(
				DiffuseColor,
				MaterialParameters,
				Frame.UpperSkyColor.rgb,
				Frame.LowerSkyColor.rgb
				);
		#endif
	#endif

	#if NEEDS_BASEPASS_FOGGING
		float4 VertexFog = BasePassInterpolants.VertexFog;
	#else
		float4 VertexFog = float4(0,0,0,1);
	#endif
		
	// Volume lighting for lit translucency
	#if (MATERIAL_SHADINGMODEL_DEFAULT_LIT || MATERIAL_SHADINGMODEL_SUBSURFACE) && (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE)
		Color += GetTranslucencyLighting(MaterialParameters, PixelMaterialInputs, BasePassInterpolants, DiffuseColor, Roughness, SpecularColor, IndirectIrradiance, MaterialAO);
	#endif

	#if !MATERIAL_SHADINGMODEL_UNLIT && USE_DEVELOPMENT_SHADERS
		Color = lerp(Color, DiffuseColor + SpecularColor, Frame.UnlitViewmodeMask);
	#endif

	half3 Emissive = GetMaterialEmissive(PixelMaterialInputs);

#if USE_DEVELOPMENT_SHADERS
	// this feature is only needed for development/editor - we can compile it out for a shipping build (see r.CompileShadersForDevelopment cvar help)
	#if METAL_SM5_PROFILE || SM5_PROFILE || SM4_PROFILE || METAL_SM4_PROFILE
		BRANCH
		if (Frame.OutOfBoundsMask > 0)
		{
			if (any(abs(MaterialParameters.AbsoluteWorldPosition - Primitive.ObjectWorldPositionAndRadius.xyz) > Primitive.ObjectBounds + 1))
			{
				float Gradient = frac(dot(MaterialParameters.AbsoluteWorldPosition, float3(.577f, .577f, .577f)) / 500.0f);
				Emissive = lerp(float3(1,1,0), float3(0,1,1), Gradient.xxx > .5f);
				Opacity = 1;
			}
		}
	#endif
#endif

	Color += Emissive;


	#if MATERIALBLENDING_TRANSLUCENT
		OutColor = half4(Color * VertexFog.a + VertexFog.rgb, Opacity);
		OutColor = RETURN_COLOR(OutColor);
	#elif MATERIALBLENDING_ADDITIVE
		OutColor = half4(Color * VertexFog.a * Opacity, 0.0f);
		OutColor = RETURN_COLOR(OutColor);
	#elif MATERIALBLENDING_MODULATE
		// RETURN_COLOR not needed with modulative blending
		half3 FoggedColor = lerp(float3(1, 1, 1), Color, VertexFog.aaa * VertexFog.aaa);
		OutColor = half4(FoggedColor, Opacity);
	#else
		// Scene color alpha is used for ScreenSpaceSubsurfaceScattering (if that is not needed it can be disabled with SUBSURFACE_CHANNEL_MODE)
		{
			FLightAccumulator LightAccumulator = (FLightAccumulator)0;

			LightAccumulator_Add(LightAccumulator, Color, 0, 1.0f);
			OutColor = RETURN_COLOR(LightAccumulator_GetResult(LightAccumulator));
		}
	#endif

	#if USES_GBUFFER
		float4 PrecomputedShadowFactors = GetPrecomputedShadowMasks(Interpolants);
		
		GBuffer.IndirectIrradiance = IndirectIrradiance;
		GBuffer.PrecomputedShadowFactors = PrecomputedShadowFactors;

		// -0.5 .. 0.5, could be optimzed as lower quality noise would be sufficient
		float QuantizationBias = PseudoRandom( MaterialParameters.SvPosition.xy ) - 0.5f;
		EncodeGBuffer(GBuffer, OutGBufferA, OutGBufferB, OutGBufferC, OutGBufferD, OutGBufferE, OutGBufferVelocity, QuantizationBias);
	#endif 

	if(bEditorWeightedZBuffering)
	{
		OutColor.a = 1;

#if MATERIALBLENDING_MASKED
		// some material might have a opacity value
		OutColor.a = GetMaterialMaskInputRaw(PixelMaterialInputs);
#endif
		// we output premultiplied alpha to we have to darken all 4 channels
		OutColor *= ClipForEditorPrimitives(MaterialParameters);

		#if EDITOR_ALPHA2COVERAGE != 0
			// per MSAA sample
			if(MSAASampleCount > 1)
			{
				OutCoverage = InCoverage & CustomAlpha2Coverage(OutColor);
			}
			else
			{
				// no MSAA is handle like per pixel
				clip(OutColor.a - GetMaterialOpacityMaskClipValue());
			}
		#else
			// per pixel
			clip(OutColor.a - GetMaterialOpacityMaskClipValue());
		#endif
	}
}
