// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
#include "UnrealTournament.h"
#include "UTCharacter.h"
#include "UTGameObjective.h"
#include "Net/UnrealNetwork.h"
#include "UTRecastNavMesh.h"
#include "UTDefensePoint.h"

AUTGameObjective::AUTGameObjective(const FObjectInitializer& ObjectInitializer)
: Super(ObjectInitializer)
{
	RootComponent = ObjectInitializer.CreateDefaultSubobject<USceneComponent, USceneComponent>(this, TEXT("DummyRoot"), false);
	CarriedObjectClass = NULL;
	InitialSpawnDelay = 0.0f;
	SetReplicates(true);
	bReplicateMovement = true;
	bAlwaysRelevant = true;
	NetPriority=1.0;
	BestViewYaw = 0.f;
	LastSecondSaveDistance = 2000.f;
	TeamNum = 255;
	bAutogenerateDefensePoints = true;
}

void AUTGameObjective::GetLifetimeReplicatedProps(TArray< FLifetimeProperty > & OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(AUTGameObjective, CarriedObject);
	DOREPLIFETIME(AUTGameObjective, CarriedObjectState);
	DOREPLIFETIME(AUTGameObjective, CarriedObjectHolder);
}

void AUTGameObjective::InitializeObjective()
{
	if (InitialSpawnDelay > 0.0f)
	{
		FTimerHandle TempHandle;
		GetWorldTimerManager().SetTimer(TempHandle, this, &AUTGameObjective::CreateCarriedObject, InitialSpawnDelay, false);
	}
	else
	{
		CreateCarriedObject();
	}

	if (bAutogenerateDefensePoints)
	{
		AUTRecastNavMesh* NavData = GetUTNavData(GetWorld());
		if (NavData != NULL)
		{
			const FVector MyLoc = GetActorLocation() + FVector(0.0f, 0.0f, 45.0f);
			const UUTPathNode* MyNode = NavData->FindNearestNode(MyLoc, NavData->GetPOIExtent(this));
			TArray<const UUTPathNode*> AllNodes = NavData->GetAllNodes();
			// sort nodes by overall area viability as a defense point
			AllNodes.Sort([](const UUTPathNode& A, const UUTPathNode& B)
			{
				// rate based on number of linked paths and number of polys in this node (implying area size)
				// TODO: calculate actual poly area?
				float RatingA = 0.5f / FMath::Max<int32>(1, A.Paths.Num()) + 0.5f / FMath::Max<int32>(1, A.Polys.Num());
				float RatingB = 0.5f / FMath::Max<int32>(1, B.Paths.Num()) + 0.5f / FMath::Max<int32>(1, A.Polys.Num());
				return RatingA > RatingB;
			});
			struct FPotentialDefensePoint
			{
				FVector Loc;
				float Distance;
			};
			TArray<FPotentialDefensePoint> Choices;
			int32 NumNodesWithChoices = 0;
			for (const UUTPathNode* Node : AllNodes)
			{
				bool bGotChoice = false;
				if (Node != MyNode)
				{
					for (NavNodeRef TestPoly : Node->Polys)
					{
						const FVector TestLoc = NavData->GetPolyCenter(TestPoly) + FVector(0.0f, 0.0f, NavData->GetPOIExtent(NULL).Z);
						if (!GetWorld()->LineTraceTestByChannel(MyLoc, TestLoc, ECC_Pawn, FCollisionQueryParams(), WorldResponseParams))
						{
							new(Choices) FPotentialDefensePoint{ TestLoc, (TestLoc - MyLoc).Size() };
							if (!bGotChoice)
							{
								NumNodesWithChoices++;
								bGotChoice = true;
							}
						}
					}
					// bail once we have a reasonable variety of options
					if (NumNodesWithChoices > 6)
					{
						break;
					}
				}
			}
			Choices.Sort([](const FPotentialDefensePoint& A, const FPotentialDefensePoint& B) { return A.Distance > B.Distance; });
			Choices.SetNum(FMath::Min<int32>(Choices.Num(), 4));
			for (const FPotentialDefensePoint& Pt : Choices)
			{
				FActorSpawnParameters Params;
				Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
				AUTDefensePoint* NewPoint = GetWorld()->SpawnActor<AUTDefensePoint>(Pt.Loc, (MyLoc - Pt.Loc).Rotation(), Params);
				if (NewPoint != NULL)
				{
					NewPoint->Objective = this;
					NewPoint->BasePriority = FMath::Max<int32>(1, NewPoint->BasePriority / 2);
					DefensePoints.Add(NewPoint);
				}
			}
		}
	}
}

void AUTGameObjective::CreateCarriedObject()
{
	if (CarriedObjectClass == NULL) return;	// Sanity

	FActorSpawnParameters Params;
	Params.Owner = this;

	CarriedObject = GetWorld()->SpawnActor<AUTCarriedObject>(CarriedObjectClass, GetActorLocation() + FVector(0,0,96), GetActorRotation(), Params);
	if (CarriedObject != NULL)
	{
		CarriedObject->Init(this);
	}
	else
	{
		UE_LOG(UT,Warning,TEXT("%s Could not create an object of type %s"), *GetNameSafe(this), *GetNameSafe(CarriedObjectClass));
	}
}

AUTCarriedObject* AUTGameObjective::GetCarriedObject() const
{
	return CarriedObject;
}

FName AUTGameObjective::GetCarriedObjectState() const
{
	return CarriedObjectState;
}

AUTPlayerState* AUTGameObjective::GetCarriedObjectHolder()
{
	return CarriedObjectHolder;
}

void AUTGameObjective::ObjectWasPickedUp(AUTCharacter* NewHolder, bool bWasHome)
{
	CarriedObjectHolder = NewHolder != NULL ? Cast<AUTPlayerState>(NewHolder->PlayerState) : NULL;
}

void AUTGameObjective::ObjectWasDropped(AUTCharacter* LastHolder)
{
	CarriedObjectHolder = NULL;
}

void AUTGameObjective::ObjectReturnedHome(AUTCharacter* Returner)
{
	CarriedObjectHolder = NULL;
}

void AUTGameObjective::ObjectStateWasChanged(FName NewObjectState)
{
	if (Role==ROLE_Authority)
	{
		CarriedObjectState = NewObjectState;
		OnObjectStateChanged();
	}
}

void AUTGameObjective::OnObjectStateChanged()
{
	// Subclass me
}

bool AUTGameObjective::ActorIsNearMe(AActor *Other) const
{
	return ((Other->GetActorLocation() - GetActorLocation()).Size() < LastSecondSaveDistance);
}